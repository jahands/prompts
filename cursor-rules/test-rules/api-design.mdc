---
description: RESTful API design best practices including resource naming, HTTP methods, status codes, error handling, pagination, and versioning
globs:
alwaysApply: false
---
<restful-api-design>

<title>RESTful API Design Standards</title>

<overview>Comprehensive guidelines for designing consistent, scalable RESTful APIs following industry best practices and standards</overview>

<resource-naming>
<rules>
- Use plural nouns for collections: `/users`, `/products`, `/orders`
- Use kebab-case for multi-word resources: `/user-profiles`, `/shopping-carts`
- Nest related resources logically: `/users/{id}/orders`, `/posts/{id}/comments`
- Avoid verbs in endpoints - let HTTP methods indicate actions
- Keep nesting shallow - maximum 3 levels deep
- Use query parameters for filtering: `/products?category=electronics&inStock=true`
</rules>

<examples>
<example type="good">
```
GET    /users              # List all users
GET    /users/123          # Get specific user
POST   /users              # Create new user
PUT    /users/123          # Update entire user
PATCH  /users/123          # Partial update
DELETE /users/123          # Delete user
GET    /users/123/orders   # Get user's orders
```
</example>

<example type="bad">
```
GET    /getUsers           # Don't use verbs
POST   /users/create       # Redundant verb
GET    /user               # Use plural
GET    /users/123/orders/456/items/789/details  # Too deeply nested
```
</example>
</examples>
</resource-naming>

<http-methods>
<rules>
- GET: Retrieve resources (idempotent, cacheable)
- POST: Create new resources (not idempotent)
- PUT: Full update/replace resource (idempotent)
- PATCH: Partial update resource (idempotent)
- DELETE: Remove resource (idempotent)
- HEAD: Get headers only (same as GET without body)
- OPTIONS: Get allowed methods for resource
</rules>

<method-safety>
- Safe methods (no side effects): GET, HEAD, OPTIONS
- Unsafe methods (modify state): POST, PUT, PATCH, DELETE
- Always use appropriate method for the operation
</method-safety>
</http-methods>

<status-codes>
<success-codes>
- `200 OK` - Successful GET, PUT, PATCH, or DELETE
- `201 Created` - Successful POST (include Location header)
- `202 Accepted` - Request accepted for async processing
- `204 No Content` - Successful DELETE or action with no response body
</success-codes>

<client-error-codes>
- `400 Bad Request` - Invalid request syntax or parameters
- `401 Unauthorized` - Missing or invalid authentication
- `403 Forbidden` - Authenticated but not authorized
- `404 Not Found` - Resource doesn't exist
- `409 Conflict` - Request conflicts with current state
- `422 Unprocessable Entity` - Validation errors
- `429 Too Many Requests` - Rate limit exceeded
</client-error-codes>

<server-error-codes>
- `500 Internal Server Error` - Unexpected server error
- `502 Bad Gateway` - Invalid response from upstream
- `503 Service Unavailable` - Server temporarily unavailable
- `504 Gateway Timeout` - Upstream server timeout
</server-error-codes>
</status-codes>

<error-response-format>
<structure>
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed",
    "timestamp": "2024-01-15T10:30:00Z",
    "path": "/api/v1/users",
    "details": [
      {
        "field": "email",
        "code": "INVALID_FORMAT",
        "message": "Email format is invalid"
      },
      {
        "field": "age",
        "code": "OUT_OF_RANGE", 
        "message": "Age must be between 18 and 120"
      }
    ]
  }
}
```
</structure>

<requirements>
- Consistent error structure across all endpoints
- Machine-readable error codes
- Human-readable messages
- Include timestamp and request path
- Provide field-level details for validation errors
- Use appropriate HTTP status codes
- Never expose internal implementation details
</requirements>
</error-response-format>

<pagination-strategies>
<offset-based>
<when-to-use>Simple use cases, stable datasets</when-to-use>
<implementation>
```
GET /users?offset=20&limit=10

Response headers:
X-Total-Count: 150
X-Page-Count: 15

Response body:
{
  "data": [...],
  "pagination": {
    "offset": 20,
    "limit": 10,
    "total": 150,
    "hasNext": true,
    "hasPrev": true
  }
}
```
</implementation>
</offset-based>

<cursor-based>
<when-to-use>Large datasets, real-time data, better performance</when-to-use>
<implementation>
```
GET /users?cursor=eyJpZCI6MTIzfQ&limit=10

Response:
{
  "data": [...],
  "pagination": {
    "nextCursor": "eyJpZCI6MTMzfQ",
    "prevCursor": "eyJpZCI6MTEzfQ",
    "hasNext": true,
    "hasPrev": true
  }
}
```
</implementation>
</cursor-based>

<best-practices>
- Default page size: 20-50 items
- Maximum page size: 100-200 items
- Include total count in headers or response
- Provide next/previous links when applicable
- Use consistent parameter names across endpoints
</best-practices>
</pagination-strategies>

<versioning-approaches>
<uri-versioning>
<format>`/api/v1/resources`</format>
<pros>
- Clear and explicit
- Easy to route
- Cache-friendly
</pros>
<example>
```
https://api.example.com/v1/users
https://api.example.com/v2/users
```
</example>
</uri-versioning>

<header-versioning>
<format>Custom header: `API-Version: 1.0`</format>
<pros>
- Clean URLs
- Multiple version strategies
</pros>
<example>
```
GET /users
API-Version: 1.0
```
</example>
</header-versioning>

<content-negotiation>
<format>Accept header: `application/vnd.company.v1+json`</format>
<pros>
- RESTful approach
- Fine-grained control
</pros>
<example>
```
GET /users
Accept: application/vnd.company.v2+json
```
</example>
</content-negotiation>

<versioning-rules>
- Choose one approach and stick to it
- Version from the start (v1)
- Only increment for breaking changes
- Support at least one previous version
- Deprecate with clear timelines
- Document version differences
</versioning-rules>
</versioning-approaches>

<additional-best-practices>
- Use HTTPS for all endpoints
- Implement proper authentication (OAuth 2.0, JWT)
- Add rate limiting with clear headers
- Support content negotiation (JSON default, XML optional)
- Use ISO 8601 for dates: `2024-01-15T10:30:00Z`
- Implement CORS for browser access
- Provide comprehensive API documentation
- Use consistent naming conventions throughout
- Return created resource on POST
- Support filtering, sorting, and field selection
- Implement request ID tracking
- Use compression for large responses
</additional-best-practices>

</restful-api-design>