---
description: RESTful API design patterns including resource naming, HTTP methods, status codes, error handling, pagination, and versioning
globs:
alwaysApply: false
---
<restful-api-design>

<title>RESTful API Design Standards</title>

<resource-naming>
<rules>
- Use plural nouns for collections: `/users`, `/products`, `/orders`
- Use kebab-case for multi-word resources: `/user-profiles`, `/shopping-carts`
- Nest resources to show relationships: `/users/{id}/orders`
- Avoid verbs in endpoints - let HTTP methods convey actions
- Keep nesting shallow (max 3 levels): `/shops/{id}/products/{id}/reviews`
</rules>
</resource-naming>

<http-methods>
<method-usage>
- `GET`: Retrieve resources (idempotent, cacheable)
- `POST`: Create new resources (not idempotent)
- `PUT`: Full update/replace resource (idempotent)
- `PATCH`: Partial update resource (idempotent)
- `DELETE`: Remove resource (idempotent)
- `HEAD`: Get headers only (same as GET without body)
- `OPTIONS`: Get allowed methods for resource
</method-usage>
</http-methods>

<status-codes>
<success-codes>
- `200 OK`: Successful GET, PUT, PATCH, DELETE
- `201 Created`: Successful POST with new resource
- `202 Accepted`: Request accepted for async processing
- `204 No Content`: Successful request with no response body
</success-codes>

<client-error-codes>
- `400 Bad Request`: Invalid request syntax or parameters
- `401 Unauthorized`: Missing or invalid authentication
- `403 Forbidden`: Authenticated but not authorized
- `404 Not Found`: Resource doesn't exist
- `409 Conflict`: Request conflicts with current state
- `422 Unprocessable Entity`: Valid syntax but semantic errors
</client-error-codes>

<server-error-codes>
- `500 Internal Server Error`: Generic server failure
- `502 Bad Gateway`: Invalid response from upstream
- `503 Service Unavailable`: Temporary unavailability
- `504 Gateway Timeout`: Upstream timeout
</server-error-codes>
</status-codes>

<error-response-format>
<structure>
```json
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Validation failed for the request",
    "details": [
      {
        "field": "email",
        "code": "INVALID_FORMAT",
        "message": "Email format is invalid"
      }
    ],
    "timestamp": "2024-01-15T10:30:00Z",
    "path": "/api/v1/users",
    "requestId": "550e8400-e29b-41d4-a716-446655440000"
  }
}
```
</structure>

<requirements>
- Include machine-readable error codes
- Provide human-readable messages
- Add field-level details for validation errors
- Include request tracking information
- Use consistent error structure across all endpoints
</requirements>
</error-response-format>

<pagination>
<strategies>
<strategy type="offset-based">
```
GET /api/v1/products?offset=20&limit=10

Response headers:
X-Total-Count: 150
Link: <.../products?offset=30&limit=10>; rel="next",
      <.../products?offset=10&limit=10>; rel="prev"
```
</strategy>

<strategy type="cursor-based">
```
GET /api/v1/products?cursor=eyJpZCI6MTAwfQ&limit=10

Response:
{
  "data": [...],
  "pagination": {
    "next_cursor": "eyJpZCI6MTEwfQ",
    "has_more": true
  }
}
```
</strategy>

<strategy type="page-based">
```
GET /api/v1/products?page=3&per_page=10

Response:
{
  "data": [...],
  "pagination": {
    "page": 3,
    "per_page": 10,
    "total_pages": 15,
    "total_items": 150
  }
}
```
</strategy>
</strategies>

<best-practices>
- Default to cursor-based for large datasets
- Include total count in headers to avoid extra queries
- Support consistent limit parameter across endpoints
- Set reasonable default and maximum limits
- Return pagination metadata in consistent format
</best-practices>
</pagination>

<versioning>
<approaches>
<approach type="uri-versioning">
```
GET /api/v1/users
GET /api/v2/users
```
</approach>

<approach type="header-versioning">
```
GET /api/users
Accept: application/vnd.company.v2+json
```
</approach>

<approach type="query-parameter">
```
GET /api/users?version=2
```
</approach>
</approaches>

<recommendations>
- Use URI versioning for clarity and simplicity
- Version at the API level, not individual endpoints
- Maintain at least one previous version
- Document deprecation timeline clearly
- Use semantic versioning for version numbers
- Avoid breaking changes within major versions
</recommendations>
</versioning>

<additional-patterns>
<filtering>
```
GET /api/v1/products?category=electronics&price_min=100&price_max=500
```
</filtering>

<sorting>
```
GET /api/v1/products?sort=price,-created_at
```
</sorting>

<field-selection>
```
GET /api/v1/users?fields=id,name,email
```
</field-selection>

<search>
```
GET /api/v1/products?q=laptop&category=electronics
```
</search>
</additional-patterns>

<examples>
<example type="complete-api-flow">
```http
# Create a new user
POST /api/v1/users
Content-Type: application/json

{
  "name": "John Doe",
  "email": "john@example.com"
}

Response: 201 Created
Location: /api/v1/users/123
{
  "id": "123",
  "name": "John Doe",
  "email": "john@example.com",
  "created_at": "2024-01-15T10:30:00Z"
}

# Get user's orders with pagination
GET /api/v1/users/123/orders?page=1&per_page=20

Response: 200 OK
{
  "data": [
    {
      "id": "456",
      "user_id": "123",
      "total": 99.99,
      "status": "completed"
    }
  ],
  "pagination": {
    "page": 1,
    "per_page": 20,
    "total_pages": 3,
    "total_items": 45
  }
}

# Partial update
PATCH /api/v1/users/123
Content-Type: application/json

{
  "email": "newemail@example.com"
}

Response: 200 OK

# Handle error
POST /api/v1/users
Content-Type: application/json

{
  "name": "Jane"
}

Response: 422 Unprocessable Entity
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Request validation failed",
    "details": [
      {
        "field": "email",
        "code": "REQUIRED_FIELD",
        "message": "Email is required"
      }
    ]
  }
}
```
</example>
</examples>

</restful-api-design>