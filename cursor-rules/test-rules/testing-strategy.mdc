---
description: Comprehensive testing practices including unit tests, integration tests, naming conventions, mocking, test data, and coverage
globs:
alwaysApply: false
---
<testing-strategy>

<title>Comprehensive Testing Strategy</title>

<context>
<applies-to>All test files, test suites, and testing utilities across the codebase</applies-to>
</context>

<overview>Guidelines for structuring tests, managing test data, mocking dependencies, and ensuring adequate coverage across unit and integration tests</overview>

<key-concepts>
- Arrange-Act-Assert pattern
- Test isolation and independence
- Mocking vs stubbing vs faking
- Test data factories
- Coverage metrics and thresholds
- Test pyramid principles
</key-concepts>

<rules>
<rule>
<name>Unit Test Structure</name>
<requirements>
- Follow Arrange-Act-Assert (AAA) pattern
- One assertion per test preferred
- Each test must be independent
- Use descriptive test names that explain what and why
- Group related tests in describe blocks
- Setup and teardown in beforeEach/afterEach
- Avoid test interdependencies
- Keep tests focused and atomic
</requirements>
</rule>

<rule>
<name>Integration Test Patterns</name>
<requirements>
- Test complete user workflows
- Use real dependencies when possible
- Mock only external services
- Test database transactions end-to-end
- Verify API contracts
- Include error scenarios
- Test timeout and retry behaviors
- Clean up test data after each run
</requirements>
</rule>

<rule>
<name>Test Naming Conventions</name>
<requirements>
- describe blocks: Class or module name
- it blocks: "should [expected behavior] when [condition]"
- Test files: `*.test.ts` or `*.spec.ts`
- Integration tests: `*.integration.test.ts`
- E2E tests: `*.e2e.test.ts`
- Use consistent terminology across test suite
- Avoid abbreviations in test names
</requirements>
</rule>

<rule>
<name>Mocking Strategies</name>
<requirements>
- Mock at the boundaries (external services, databases)
- Prefer dependency injection for testability
- Use test doubles appropriately: mocks for behavior, stubs for state
- Avoid mocking internal modules
- Create reusable mock factories
- Type-safe mocks matching real interfaces
- Reset mocks between tests
- Document complex mock behaviors
</requirements>
</rule>

<rule>
<name>Test Data Management</name>
<requirements>
- Use factories for test object creation
- Randomize test data to catch edge cases
- Minimal data for each test case
- Explicit about important values
- Use builders for complex objects
- Separate test data from test logic
- Version controlled test fixtures
- Avoid hard-coded values
</requirements>
</rule>

<rule>
<name>Coverage Requirements</name>
<requirements>
- Minimum 80% code coverage
- 100% coverage for critical paths
- Branch coverage over line coverage
- Exclude generated code from metrics
- Coverage reports in CI pipeline
- Track coverage trends over time
- Focus on meaningful tests over coverage numbers
- Document intentionally uncovered code
</requirements>
</rule>
</rules>

<examples>
<example type="unit-test-structure">
```typescript
describe('UserService', () => {
  let userService: UserService;
  let mockUserRepository: jest.Mocked<UserRepository>;

  beforeEach(() => {
    mockUserRepository = createMockUserRepository();
    userService = new UserService(mockUserRepository);
  });

  describe('createUser', () => {
    it('should create a new user when valid data is provided', async () => {
      // Arrange
      const userData = buildUser({ email: 'test@example.com' });
      mockUserRepository.save.mockResolvedValue(userData);

      // Act
      const result = await userService.createUser(userData);

      // Assert
      expect(result).toEqual(userData);
      expect(mockUserRepository.save).toHaveBeenCalledWith(userData);
    });

    it('should throw ValidationError when email is invalid', async () => {
      // Arrange
      const userData = buildUser({ email: 'invalid-email' });

      // Act & Assert
      await expect(userService.createUser(userData))
        .rejects.toThrow(ValidationError);
    });
  });
});
```
</example>

<example type="test-data-factory">
```typescript
// Test data factory with builder pattern
export const buildUser = (overrides?: Partial<User>): User => ({
  id: faker.datatype.uuid(),
  email: faker.internet.email(),
  name: faker.name.fullName(),
  createdAt: faker.date.past(),
  role: 'user',
  ...overrides,
});

export const buildAdminUser = (overrides?: Partial<User>): User => 
  buildUser({ role: 'admin', ...overrides });

// Usage in tests
const testUser = buildUser({ email: 'specific@test.com' });
const randomUsers = Array.from({ length: 5 }, () => buildUser());
```
</example>

<example type="integration-test">
```typescript
describe('POST /api/users (Integration)', () => {
  let app: Application;
  let testDb: TestDatabase;

  beforeAll(async () => {
    testDb = await createTestDatabase();
    app = createApp({ database: testDb });
  });

  afterEach(async () => {
    await testDb.cleanAll();
  });

  afterAll(async () => {
    await testDb.disconnect();
  });

  it('should create user and send welcome email', async () => {
    // Arrange
    const emailService = mockEmailService();
    const userData = { email: 'new@user.com', name: 'Test User' };

    // Act
    const response = await request(app)
      .post('/api/users')
      .send(userData)
      .expect(201);

    // Assert
    const dbUser = await testDb.users.findByEmail(userData.email);
    expect(dbUser).toBeDefined();
    expect(response.body.id).toBe(dbUser.id);
    expect(emailService.sendWelcomeEmail).toHaveBeenCalledWith(userData.email);
  });
});
```
</example>
</examples>

<test-organization>
<structure>
```
src/
  components/
    Button/
      Button.tsx
      Button.test.tsx
  services/
    UserService.ts
    UserService.test.ts
    UserService.integration.test.ts
  __tests__/
    e2e/
      user-flow.e2e.test.ts
    fixtures/
      users.json
    factories/
      userFactory.ts
    utils/
      testDatabase.ts
```
</structure>
</test-organization>

<anti-patterns>
- Testing implementation details instead of behavior
- Excessive mocking leading to brittle tests
- Shared state between tests
- Testing framework code
- Snapshot tests for business logic
- Ignoring flaky tests
- Testing private methods directly
- Large test setups indicating design issues
</anti-patterns>

</testing-strategy>