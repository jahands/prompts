---
description: Comprehensive testing practices including unit tests, integration tests, naming conventions, mocking, test data, and coverage
globs:
alwaysApply: false
---
<testing-strategy>

<title>Comprehensive Testing Strategy</title>

<overview>Standards for writing maintainable, reliable tests across unit, integration, and end-to-end levels with proper mocking, data management, and coverage</overview>

<key-concepts>
- Test isolation and independence
- Arrange-Act-Assert pattern
- Test doubles (mocks, stubs, spies)
- Test data factories
- Coverage metrics and targets
</key-concepts>

<rules>
<rule>
<name>Unit Test Structure</name>
<requirements>
- Follow AAA pattern: Arrange, Act, Assert
- One assertion per test (when practical)
- Test one behavior per test method
- Keep tests independent - no shared state
- Use descriptive test names that explain what and why
- Group related tests in describe/context blocks
</requirements>
</rule>

<rule>
<name>Test Naming Conventions</name>
<requirements>
- Unit tests: `should_[expected]_when_[condition]`
- Integration tests: `test_[feature]_[scenario]`
- Test files: `*.test.ts`, `*.spec.ts` for unit tests
- Test files: `*.integration.test.ts` for integration tests
- Test suites: Use `describe()` blocks matching class/module names
- Nested contexts: Use `describe()` or `context()` for scenarios
</requirements>
</rule>

<rule>
<name>Mocking Strategies</name>
<requirements>
- Mock external dependencies (APIs, databases, file systems)
- Don't mock the unit under test
- Use test doubles appropriately:
  - Stub: Pre-programmed responses
  - Mock: Verify interactions
  - Spy: Record calls while executing real code
  - Fake: Simplified working implementation
- Reset mocks between tests
- Prefer dependency injection for testability
</requirements>
</rule>

<rule>
<name>Integration Test Patterns</name>
<requirements>
- Test real integrations with external systems
- Use test containers for databases
- Clean up test data after each test
- Test happy paths and error scenarios
- Verify data persistence and retrieval
- Test transaction boundaries
- Use realistic test data volumes
</requirements>
</rule>

<rule>
<name>Test Data Management</name>
<requirements>
- Use factories or builders for test objects
- Centralize test data creation
- Make test data explicit in tests
- Use minimal data needed for each test
- Avoid hard-coded magic values
- Generate unique identifiers for parallel tests
- Clean up test data in afterEach/afterAll hooks
</requirements>
</rule>

<rule>
<name>Coverage Requirements</name>
<requirements>
- Minimum 80% code coverage for new code
- 100% coverage for critical business logic
- Focus on branch coverage, not just line coverage
- Exclude generated code from coverage
- Test edge cases and error paths
- Don't write tests just for coverage
- Review uncovered code in PR reviews
</requirements>
</rule>
</rules>

<examples>
<example type="unit-test-structure">
```typescript
describe('UserService', () => {
  let userService: UserService;
  let mockUserRepository: jest.Mocked<UserRepository>;
  let mockEmailService: jest.Mocked<EmailService>;

  beforeEach(() => {
    // Arrange - Setup mocks
    mockUserRepository = createMock<UserRepository>();
    mockEmailService = createMock<EmailService>();
    userService = new UserService(mockUserRepository, mockEmailService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('createUser', () => {
    it('should_create_user_and_send_welcome_email_when_valid_data_provided', async () => {
      // Arrange
      const userData = UserFactory.build({ email: 'test@example.com' });
      const savedUser = { ...userData, id: '123' };
      mockUserRepository.save.mockResolvedValue(savedUser);
      mockEmailService.sendWelcomeEmail.mockResolvedValue(true);

      // Act
      const result = await userService.createUser(userData);

      // Assert
      expect(result).toEqual(savedUser);
      expect(mockUserRepository.save).toHaveBeenCalledWith(userData);
      expect(mockEmailService.sendWelcomeEmail).toHaveBeenCalledWith(savedUser.email);
    });

    it('should_throw_error_when_email_already_exists', async () => {
      // Arrange
      const userData = UserFactory.build();
      mockUserRepository.findByEmail.mockResolvedValue({ id: 'existing' } as User);

      // Act & Assert
      await expect(userService.createUser(userData))
        .rejects
        .toThrow('Email already exists');
      
      expect(mockEmailService.sendWelcomeEmail).not.toHaveBeenCalled();
    });
  });
});
```
</example>

<example type="test-data-factory">
```typescript
// test/factories/user.factory.ts
export class UserFactory {
  private static sequence = 0;

  static build(overrides: Partial<User> = {}): User {
    const id = ++this.sequence;
    return {
      id: `user-${id}`,
      email: `user${id}@test.com`,
      name: `Test User ${id}`,
      createdAt: new Date(),
      ...overrides
    };
  }

  static buildMany(count: number, overrides: Partial<User> = {}): User[] {
    return Array.from({ length: count }, () => this.build(overrides));
  }
}

// Usage in tests
const user = UserFactory.build({ role: 'admin' });
const users = UserFactory.buildMany(5);
```
</example>

<example type="integration-test">
```typescript
describe('UserAPI Integration Tests', () => {
  let app: Application;
  let database: Database;

  beforeAll(async () => {
    // Setup test database
    database = await createTestDatabase();
    app = await createTestApp(database);
  });

  afterAll(async () => {
    await database.close();
  });

  afterEach(async () => {
    // Clean up test data
    await database.query('DELETE FROM users WHERE email LIKE $1', ['%@test.com']);
  });

  describe('POST /users', () => {
    test('test_user_creation_persists_to_database', async () => {
      // Arrange
      const userData = {
        email: 'integration@test.com',
        name: 'Integration Test User',
        password: 'securePassword123'
      };

      // Act
      const response = await request(app)
        .post('/users')
        .send(userData)
        .expect(201);

      // Assert - Check API response
      expect(response.body).toMatchObject({
        id: expect.any(String),
        email: userData.email,
        name: userData.name
      });
      expect(response.body.password).toBeUndefined();

      // Assert - Verify database state
      const dbUser = await database.query(
        'SELECT * FROM users WHERE email = $1',
        [userData.email]
      );
      expect(dbUser.rows).toHaveLength(1);
      expect(dbUser.rows[0].password_hash).toBeDefined();
    });
  });
});
```
</example>
</examples>

</testing-strategy>