---
description: Comprehensive testing practices including unit tests, integration tests, naming conventions, mocking strategies, test data management, and coverage requirements
globs:
alwaysApply: false
---
<testing-strategy>

<title>Comprehensive Testing Practices</title>

<context>
<applies-to>All test files, test utilities, and testing-related code</applies-to>
</context>

<overview>Guidelines for writing maintainable, reliable tests with consistent patterns across unit tests, integration tests, and end-to-end tests</overview>

<key-concepts>
- Test isolation and independence
- Arrange-Act-Assert pattern
- Test doubles (mocks, stubs, spies)
- Test data factories
- Coverage metrics and thresholds
</key-concepts>

<rules>
<rule>
<name>Test File Organization</name>
<requirements>
- Place unit tests adjacent to source files: `module.ts` â†’ `module.test.ts`
- Group integration tests in `__tests__/integration/`
- Group e2e tests in `__tests__/e2e/`
- Use `.test.ts` or `.spec.ts` consistently throughout project
- Mirror source directory structure in test directories
</requirements>
</rule>

<rule>
<name>Test Naming Conventions</name>
<requirements>
- Use descriptive test names that explain what is being tested
- Format: `should [expected behavior] when [condition]`
- Group related tests with `describe` blocks matching class/module names
- Use `it` for individual test cases
- Avoid generic names like "works correctly" or "test 1"
</requirements>
</rule>

<rule>
<name>Unit Test Structure</name>
<requirements>
- Follow Arrange-Act-Assert (AAA) pattern
- One assertion per test (with exceptions for related assertions)
- Test public API only, not implementation details
- Each test must be independent and runnable in isolation
- Clean up resources in `afterEach` hooks
- Use `beforeEach` for common setup
</requirements>
</rule>

<rule>
<name>Mocking Strategies</name>
<requirements>
- Mock external dependencies (APIs, databases, file systems)
- Use test doubles sparingly - prefer real implementations when fast
- Create reusable mock factories for common dependencies
- Verify mock interactions when behavior is critical
- Reset mocks between tests
- Use dependency injection to facilitate mocking
</requirements>
</rule>

<rule>
<name>Test Data Management</name>
<requirements>
- Use factory functions for creating test objects
- Implement builder pattern for complex test data
- Keep test data minimal - only include required fields
- Use realistic but anonymized data
- Centralize test data creation in `__tests__/factories/`
- Avoid hardcoded magic values - use named constants
</requirements>
</rule>

<rule>
<name>Integration Test Patterns</name>
<requirements>
- Test complete user flows, not individual functions
- Use real implementations where possible
- Mock only external services and slow operations
- Set up test database with known state
- Clean up test data after each test
- Group related integration tests by feature
</requirements>
</rule>

<rule>
<name>Coverage Requirements</name>
<requirements>
- Maintain minimum 80% code coverage
- Aim for 100% coverage of critical business logic
- Exclude generated files and type definitions
- Focus on branch coverage, not just line coverage
- Add coverage reports to CI pipeline
- Document why specific code is excluded from coverage
</requirements>
</rule>

<rule>
<name>Async Testing</name>
<requirements>
- Always await async operations in tests
- Use async/await over callbacks or promises
- Set appropriate timeouts for long-running operations
- Test both success and failure paths for async code
- Verify error messages and error types
</requirements>
</rule>

<rule>
<name>Error Testing</name>
<requirements>
- Test error conditions explicitly
- Verify error messages contain helpful information
- Test boundary conditions and edge cases
- Ensure proper error propagation
- Test validation failures separately from business logic failures
</requirements>
</rule>
</rules>

<examples>
<example type="good">
```typescript
// user.service.test.ts
describe('UserService', () => {
  let userService: UserService;
  let mockUserRepository: jest.Mocked<UserRepository>;
  let mockEmailService: jest.Mocked<EmailService>;

  beforeEach(() => {
    // Arrange - common setup
    mockUserRepository = createMockUserRepository();
    mockEmailService = createMockEmailService();
    userService = new UserService(mockUserRepository, mockEmailService);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe('createUser', () => {
    it('should create user and send welcome email when valid data provided', async () => {
      // Arrange
      const userData = buildUser({ email: 'test@example.com' });
      mockUserRepository.save.mockResolvedValue(userData);

      // Act
      const result = await userService.createUser(userData);

      // Assert
      expect(result).toEqual(userData);
      expect(mockUserRepository.save).toHaveBeenCalledWith(userData);
      expect(mockEmailService.sendWelcomeEmail).toHaveBeenCalledWith(userData.email);
    });

    it('should throw ValidationError when email is invalid', async () => {
      // Arrange
      const userData = buildUser({ email: 'invalid-email' });

      // Act & Assert
      await expect(userService.createUser(userData))
        .rejects
        .toThrow(ValidationError);
      
      expect(mockUserRepository.save).not.toHaveBeenCalled();
    });
  });
});

// __tests__/factories/user.factory.ts
export function buildUser(overrides?: Partial<User>): User {
  return {
    id: faker.datatype.uuid(),
    email: faker.internet.email(),
    name: faker.name.fullName(),
    createdAt: new Date(),
    ...overrides,
  };
}

// __tests__/integration/user-registration.test.ts
describe('User Registration Flow', () => {
  let app: Application;
  let testDb: TestDatabase;

  beforeAll(async () => {
    testDb = await createTestDatabase();
    app = await createTestApp(testDb);
  });

  afterEach(async () => {
    await testDb.clear();
  });

  afterAll(async () => {
    await testDb.close();
  });

  it('should register user and send confirmation email', async () => {
    // Arrange
    const registrationData = {
      email: 'newuser@example.com',
      password: 'SecurePass123!',
      name: 'Test User'
    };

    // Act
    const response = await request(app)
      .post('/api/register')
      .send(registrationData);

    // Assert
    expect(response.status).toBe(201);
    expect(response.body).toMatchObject({
      user: {
        email: registrationData.email,
        name: registrationData.name
      }
    });

    const user = await testDb.users.findByEmail(registrationData.email);
    expect(user).toBeDefined();
    expect(user.emailVerified).toBe(false);
  });
});
```
</example>
</examples>

</testing-strategy>