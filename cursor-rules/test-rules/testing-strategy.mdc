---
description: Comprehensive testing practices including unit/integration tests, naming conventions, mocking strategies, test data management, and coverage requirements
globs:
alwaysApply: false
---
<testing-strategy>

<title>Comprehensive Testing Strategy</title>

<overview>Guidelines for test structure, naming, mocking, data management, and coverage across unit and integration tests</overview>

<key-concepts>
- Test isolation and independence
- Arrange-Act-Assert (AAA) pattern
- Test data builders and fixtures
- Mock boundaries and strategies
- Coverage metrics and requirements
</key-concepts>

<rules>
<rule>
<name>Test Structure and Organization</name>
<requirements>
- Follow AAA pattern: Arrange, Act, Assert with clear visual separation
- One assertion focus per test (multiple assertions allowed for same concept)
- Group related tests using describe/context blocks
- Place test files adjacent to source: `module.ts` â†’ `module.test.ts`
- Separate unit tests from integration tests in distinct directories
</requirements>
</rule>

<rule>
<name>Test Naming Conventions</name>
<requirements>
- Test suites: Use noun describing what is being tested
- Test cases: Start with "should" followed by expected behavior
- Include context in name when behavior varies by input
- Use `it()` for individual tests, `describe()` for grouping
- Integration tests: Prefix with scenario or user journey
</requirements>
</rule>

<rule>
<name>Unit Test Requirements</name>
<requirements>
- Test single units in isolation (functions, classes, components)
- Mock all external dependencies (databases, APIs, file systems)
- Execute in milliseconds, not seconds
- No network calls, no database access, no file I/O
- Test edge cases, error conditions, and happy paths
</requirements>
</rule>

<rule>
<name>Integration Test Requirements</name>
<requirements>
- Test interaction between multiple components
- Use real implementations where practical, test doubles where necessary
- Test database transactions and rollbacks
- Verify API contracts and error responses
- Clean up test data after each test run
</requirements>
</rule>

<rule>
<name>Mocking Strategies</name>
<requirements>
- Mock at architectural boundaries (repositories, external services)
- Prefer test doubles over mocking frameworks when simple
- Use builders for complex mock data
- Verify mock interactions only when behavior depends on it
- Never mock the unit under test
- Reset mocks between tests
</requirements>
</rule>

<rule>
<name>Test Data Management</name>
<requirements>
- Use factory functions or builders for test data creation
- Randomize variable data, fix structural data
- Share common test fixtures in dedicated files
- Make test data intentions explicit through naming
- Avoid hardcoded magic values
- Generate minimal data needed for each test
</requirements>
</rule>

<rule>
<name>Coverage Requirements</name>
<requirements>
- Minimum 80% code coverage for new code
- 100% coverage for critical business logic
- Focus on branch coverage over line coverage
- Exclude generated code and interfaces from coverage
- Write tests for uncovered edge cases, not just for metrics
- Integration tests supplement, don't replace unit test coverage
</requirements>
</rule>
</rules>

<examples>
<example type="good">
```typescript
// user.service.test.ts
describe('UserService', () => {
  let service: UserService;
  let mockRepository: jest.Mocked<UserRepository>;
  
  beforeEach(() => {
    mockRepository = createMockUserRepository();
    service = new UserService(mockRepository);
  });

  describe('createUser', () => {
    it('should create user with hashed password', async () => {
      // Arrange
      const userData = buildUser({ 
        email: 'test@example.com',
        password: 'plaintext' 
      });
      mockRepository.save.mockResolvedValue(userData);
      
      // Act
      const result = await service.createUser(userData);
      
      // Assert
      expect(result.password).not.toBe('plaintext');
      expect(result.password).toMatch(/^\$2[ayb]\$.{56}$/);
      expect(mockRepository.save).toHaveBeenCalledWith(
        expect.objectContaining({
          email: 'test@example.com',
          password: expect.stringMatching(/^\$2[ayb]\$.{56}$/)
        })
      );
    });

    it('should throw when email already exists', async () => {
      // Arrange
      mockRepository.findByEmail.mockResolvedValue(existingUser);
      
      // Act & Assert
      await expect(service.createUser(newUserData))
        .rejects.toThrow('Email already registered');
    });
  });
});
```
</example>

<example type="integration">
```typescript
// api/users.integration.test.ts
describe('User API Integration', () => {
  let app: Application;
  let testDb: TestDatabase;
  
  beforeAll(async () => {
    testDb = await createTestDatabase();
    app = createApp(testDb);
  });
  
  afterAll(async () => {
    await testDb.cleanup();
  });
  
  beforeEach(async () => {
    await testDb.truncate(['users', 'sessions']);
  });

  describe('POST /users', () => {
    it('should create user and return 201 with user data', async () => {
      // Arrange
      const userData = {
        email: 'integration@test.com',
        password: 'SecurePass123!',
        name: 'Test User'
      };
      
      // Act
      const response = await request(app)
        .post('/users')
        .send(userData);
      
      // Assert
      expect(response.status).toBe(201);
      expect(response.body).toMatchObject({
        id: expect.any(String),
        email: userData.email,
        name: userData.name
      });
      expect(response.body).not.toHaveProperty('password');
      
      // Verify database state
      const dbUser = await testDb.query('SELECT * FROM users WHERE email = ?', [userData.email]);
      expect(dbUser).toHaveLength(1);
    });
  });
});
```
</example>

<example type="test-data-builder">
```typescript
// test/builders/user.builder.ts
export function buildUser(overrides: Partial<User> = {}): User {
  return {
    id: faker.datatype.uuid(),
    email: faker.internet.email(),
    name: faker.name.fullName(),
    createdAt: faker.date.past(),
    role: 'user',
    ...overrides
  };
}

export function buildAdminUser(overrides: Partial<User> = {}): User {
  return buildUser({ role: 'admin', ...overrides });
}

// Usage in tests
const testUser = buildUser({ email: 'specific@test.com' });
const adminUser = buildAdminUser();
```
</example>
</examples>

</testing-strategy>