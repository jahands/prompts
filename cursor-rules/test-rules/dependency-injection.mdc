---
description: Guidelines for implementing dependency injection in TypeScript, including injection patterns and circular dependency resolution
globs:
alwaysApply: false
---
<dependency-injection>

<title>Dependency Injection in TypeScript</title>

<overview>Guidelines for implementing DI patterns, choosing between constructor and property injection, and resolving circular dependencies in TypeScript applications</overview>

<key-concepts>
- Inversion of Control (IoC) - classes depend on abstractions
- Constructor injection for required dependencies
- Property injection for optional dependencies
- Circular dependency detection and resolution
- DI container configuration patterns
</key-concepts>

<rules>
<rule>
<name>Constructor Injection (Default Approach)</name>
<requirements>
- Use for all required dependencies
- Declare dependencies as readonly private properties
- Always inject interfaces, never concrete implementations
- List dependencies in order: framework services, application services, repositories
- Validate required dependencies in constructor
- Maximum 5 constructor parameters (refactor if more needed)
</requirements>
</rule>

<rule>
<name>Property Injection</name>
<requirements>
- Use only for truly optional dependencies
- Mark with `@Optional()` decorator when using DI frameworks
- Initialize with sensible defaults
- Never use for core business logic dependencies
- Document why property injection was chosen
</requirements>
</rule>

<rule>
<name>Circular Dependency Resolution</name>
<requirements>
- Detect cycles early with TypeScript compiler or DI framework tools
- First approach: Extract shared interface to break cycle
- Second approach: Use factory pattern or provider
- Third approach: Lazy injection with `() => Service` pattern
- Last resort: Refactor to eliminate circular dependency
- Never use `forwardRef` without documenting why
</requirements>
</rule>

<rule>
<name>Interface Design for DI</name>
<requirements>
- Create focused interfaces with single responsibility
- Use interface segregation - clients shouldn't depend on unused methods
- Place interfaces in separate files from implementations
- Name interfaces without `I` prefix (use `UserService` not `IUserService`)
- Export interfaces from index files for clean imports
</requirements>
</rule>

<rule>
<name>DI Container Configuration</name>
<requirements>
- Register dependencies at application root
- Use symbolic tokens for non-class dependencies
- Configure lifecycle: singleton, transient, or scoped
- Validate all dependencies are registered at startup
- Use factory functions for complex initialization
</requirements>
</rule>
</rules>

<examples>
<example type="good">
```typescript
// user.service.interface.ts
export interface UserService {
  findById(id: string): Promise<User>;
  create(data: CreateUserDto): Promise<User>;
}

// email.service.interface.ts  
export interface EmailService {
  sendEmail(to: string, subject: string, body: string): Promise<void>;
}

// user.service.ts
export class UserServiceImpl implements UserService {
  constructor(
    private readonly userRepository: UserRepository,
    private readonly emailService: EmailService,
    private readonly logger: Logger
  ) {
    // Validate required dependencies
    if (!userRepository) throw new Error('UserRepository is required');
    if (!emailService) throw new Error('EmailService is required');
    if (!logger) throw new Error('Logger is required');
  }

  async create(data: CreateUserDto): Promise<User> {
    const user = await this.userRepository.save(data);
    await this.emailService.sendEmail(user.email, 'Welcome', 'Welcome to our app');
    this.logger.info(`User created: ${user.id}`);
    return user;
  }
}
```
</example>

<example type="property-injection">
```typescript
// analytics.service.ts
export class UserServiceImpl implements UserService {
  // Required dependencies via constructor
  constructor(
    private readonly userRepository: UserRepository,
    private readonly validator: Validator
  ) {}

  // Optional dependency via property injection
  @Optional()
  private analyticsService?: AnalyticsService;

  async create(data: CreateUserDto): Promise<User> {
    const user = await this.userRepository.save(data);
    
    // Only use if available
    if (this.analyticsService) {
      await this.analyticsService.track('user.created', { userId: user.id });
    }
    
    return user;
  }
}
```
</example>

<example type="circular-dependency-resolution">
```typescript
// Problem: Circular dependency between UserService and OrderService

// Solution 1: Extract shared interface
// shared.interfaces.ts
export interface UserProvider {
  findById(id: string): Promise<User>;
}

export interface OrderProvider {
  findByUserId(userId: string): Promise<Order[]>;
}

// user.service.ts
export class UserServiceImpl implements UserService, UserProvider {
  constructor(
    private readonly orderProvider: OrderProvider // Use interface, not concrete class
  ) {}
}

// Solution 2: Lazy injection
export class UserServiceImpl implements UserService {
  constructor(
    @Inject(forwardRef(() => OrderService))
    private readonly orderService: OrderService
  ) {}
}

// Solution 3: Factory pattern
export class UserServiceImpl implements UserService {
  private orderService?: OrderService;

  constructor(
    private readonly serviceFactory: ServiceFactory
  ) {}

  private getOrderService(): OrderService {
    if (!this.orderService) {
      this.orderService = this.serviceFactory.createOrderService();
    }
    return this.orderService;
  }
}
```
</example>

<example type="di-container-setup">
```typescript
// di-container.ts
import { Container } from 'inversify';

const container = new Container();

// Singleton services
container.bind<Logger>(TYPES.Logger).to(LoggerImpl).inSingletonScope();
container.bind<DatabaseConnection>(TYPES.Database).to(PostgresConnection).inSingletonScope();

// Transient services (new instance each time)
container.bind<EmailService>(TYPES.EmailService).to(EmailServiceImpl).inTransientScope();

// Request-scoped services
container.bind<UserContext>(TYPES.UserContext).to(UserContextImpl).inRequestScope();

// Factory binding for complex initialization
container.bind<UserService>(TYPES.UserService).toFactory((context) => {
  const logger = context.container.get<Logger>(TYPES.Logger);
  const db = context.container.get<DatabaseConnection>(TYPES.Database);
  const config = context.container.get<Config>(TYPES.Config);
  
  return new UserServiceImpl(
    new UserRepository(db),
    context.container.get<EmailService>(TYPES.EmailService),
    logger,
    config.userServiceOptions
  );
});

// Validate all bindings at startup
container.get<UserService>(TYPES.UserService); // Will throw if dependencies missing
```
</example>
</examples>

</dependency-injection>