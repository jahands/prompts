---
description: TypeScript dependency injection patterns, constructor vs property injection, circular dependency resolution
globs:
alwaysApply: false
---
<dependency-injection>

<title>Dependency Injection in TypeScript</title>

<overview>Guidelines for implementing dependency injection patterns, choosing between injection types, and resolving circular dependencies in TypeScript applications</overview>

<key-concepts>
- Inversion of Control (IoC) - Dependencies provided externally rather than created internally
- Constructor injection - Dependencies passed through constructor parameters
- Property injection - Dependencies set through properties after instantiation
- Circular dependencies - Two or more classes that depend on each other
- DI containers - Tools that manage dependency creation and injection
</key-concepts>

<rules>
<rule>
<name>Constructor Injection (Default Approach)</name>
<requirements>
- Use for required dependencies that are needed at instantiation
- Mark injected dependencies as `private readonly` in constructor
- Always inject interfaces, not concrete implementations
- List dependencies in order: critical services first, optional last
- Use TypeScript parameter properties for concise syntax
- Throw clear errors if required dependencies are missing
</requirements>
</rule>

<rule>
<name>Property Injection Usage</name>
<requirements>
- Use only for optional dependencies
- Use for dependencies that may change during object lifetime
- Mark properties with `@inject` decorator when using DI containers
- Provide default implementations or null object pattern
- Document why property injection was chosen over constructor injection
- Never use for core dependencies required for object functionality
</requirements>
</rule>

<rule>
<name>Circular Dependency Resolution</name>
<requirements>
- Detect circular dependencies using TypeScript compiler or DI container warnings
- First attempt: Extract shared functionality to a third service
- Second attempt: Use interfaces to break compile-time dependencies
- Last resort: Use lazy injection with factory functions or providers
- Document any circular dependency workarounds with clear explanations
- Consider refactoring architecture if circular dependencies are common
</requirements>
</rule>

<rule>
<name>Interface Design for DI</name>
<requirements>
- Define interfaces for all injected services
- Keep interfaces focused on single responsibilities
- Use interface segregation - clients shouldn't depend on unused methods
- Place interfaces in separate files from implementations
- Use descriptive names ending with contract terms like `Service`, `Repository`, `Provider`
</requirements>
</rule>

<rule>
<name>DI Container Configuration</name>
<requirements>
- Register dependencies at application startup
- Use singleton scope for stateless services
- Use transient scope for stateful services
- Configure lifecycle hooks for initialization and cleanup
- Validate all dependencies are registered before application starts
- Use factory functions for complex instantiation logic
</requirements>
</rule>
</rules>

<examples>
<example type="good">
```typescript
// interfaces/user-service.interface.ts
export interface IUserService {
  getUser(id: string): Promise<User>;
  updateUser(id: string, data: UpdateUserDto): Promise<User>;
}

// interfaces/logger.interface.ts
export interface ILogger {
  log(level: string, message: string, meta?: any): void;
}

// services/user.service.ts
export class UserService implements IUserService {
  // Constructor injection with parameter properties
  constructor(
    private readonly repository: IUserRepository,
    private readonly logger: ILogger,
    private readonly cache?: ICacheService // Optional dependency
  ) {
    if (!repository || !logger) {
      throw new Error('Required dependencies missing');
    }
  }

  async getUser(id: string): Promise<User> {
    this.logger.log('info', `Fetching user ${id}`);
    
    if (this.cache) {
      const cached = await this.cache.get(`user:${id}`);
      if (cached) return cached;
    }
    
    return this.repository.findById(id);
  }
}
```
</example>

<example type="property-injection">
```typescript
// Property injection for optional, changeable dependencies
export class NotificationService {
  @inject('IEmailProvider')
  private emailProvider?: IEmailProvider;
  
  @inject('ISmsProvider') 
  private smsProvider?: ISmsProvider;
  
  // Core functionality doesn't require these dependencies
  async notify(user: User, message: string): Promise<void> {
    const tasks: Promise<void>[] = [];
    
    if (this.emailProvider && user.email) {
      tasks.push(this.emailProvider.send(user.email, message));
    }
    
    if (this.smsProvider && user.phone) {
      tasks.push(this.smsProvider.send(user.phone, message));
    }
    
    await Promise.allSettled(tasks);
  }
}
```
</example>

<example type="circular-dependency-resolution">
```typescript
// Problem: Circular dependency between UserService and AuthService
// Solution 1: Extract shared logic to third service
export interface IUserValidator {
  validateUser(user: User): boolean;
}

export class UserValidator implements IUserValidator {
  validateUser(user: User): boolean {
    return user.isActive && !user.isDeleted;
  }
}

// Now both services can depend on IUserValidator
export class UserService {
  constructor(private readonly validator: IUserValidator) {}
}

export class AuthService {
  constructor(private readonly validator: IUserValidator) {}
}

// Solution 2: Use lazy injection for unavoidable circular dependencies
export class OrderService {
  constructor(
    private readonly paymentProvider: () => IPaymentService // Factory function
  ) {}
  
  async processOrder(order: Order): Promise<void> {
    // Lazy resolution when actually needed
    const paymentService = this.paymentProvider();
    await paymentService.charge(order.total);
  }
}
```
</example>

<example type="container-configuration">
```typescript
// DI Container setup (using InversifyJS as example)
import { Container } from 'inversify';

const container = new Container();

// Singleton services (stateless)
container.bind<ILogger>('ILogger')
  .to(ConsoleLogger)
  .inSingletonScope();

container.bind<IUserRepository>('IUserRepository')
  .to(PostgresUserRepository)
  .inSingletonScope();

// Transient services (stateful)
container.bind<IUserService>('IUserService')
  .to(UserService)
  .inTransientScope();

// Factory for complex instantiation
container.bind<IDbConnection>('IDbConnection')
  .toFactory((context) => {
    return () => {
      const config = context.container.get<IConfig>('IConfig');
      return new DbConnection(config.database);
    };
  });

// Validate container configuration
try {
  container.get<IUserService>('IUserService');
  console.log('DI container configured successfully');
} catch (error) {
  console.error('DI configuration error:', error);
  process.exit(1);
}
```
</example>
</examples>

<anti-patterns>
- Creating dependencies inside constructors using `new`
- Using static classes or singletons instead of DI
- Injecting the DI container itself (service locator anti-pattern)
- Having constructors with more than 5 dependencies (indicates poor separation of concerns)
- Using property injection for required dependencies
- Circular dependencies between more than 2 classes
- Mixing business logic in DI configuration
</anti-patterns>

</dependency-injection>