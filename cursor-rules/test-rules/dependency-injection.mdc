---
description: TypeScript dependency injection patterns, constructor vs property injection, and circular dependency resolution
globs:
alwaysApply: false
---
<dependency-injection>

<title>Dependency Injection in TypeScript</title>

<overview>Guidelines for implementing DI patterns, choosing between injection types, and resolving circular dependencies in TypeScript applications</overview>

<key-concepts>
- Inversion of Control (IoC) principle
- Constructor injection for required dependencies
- Property injection for optional dependencies
- Circular dependency detection and resolution
- Interface-based injection
</key-concepts>

<rules>
<rule>
<name>Constructor Injection</name>
<requirements>
- Use constructor injection as the default for required dependencies
- Mark injected dependencies with `private readonly`
- Always inject interfaces, never concrete implementations
- Order parameters: required dependencies first, optional last
- Use parameter decorators when using DI frameworks
</requirements>
</rule>

<rule>
<name>Property Injection</name>
<requirements>
- Use property injection only for optional dependencies
- Mark properties with `@Optional()` decorator when using frameworks
- Initialize with sensible defaults
- Document why property injection was chosen
- Avoid for core business logic dependencies
</requirements>
</rule>

<rule>
<name>Circular Dependency Resolution</name>
<requirements>
- Detect cycles early with TypeScript compiler or linting tools
- Extract shared functionality to a third service
- Use lazy injection with factory functions as last resort
- Consider if the circular dependency indicates poor design
- Document any intentional circular dependencies
</requirements>
</rule>

<rule>
<name>Interface Design</name>
<requirements>
- Define interfaces for all injected dependencies
- Keep interfaces focused and single-purpose
- Use interface segregation principle
- Place interfaces in separate files from implementations
- Prefix interface names with `I` only if team convention requires it
</requirements>
</rule>
</rules>

<examples>
<example type="constructor-injection">
```typescript
// interfaces/logger.interface.ts
export interface ILogger {
  log(message: string): void;
  error(message: string, error?: Error): void;
}

// interfaces/database.interface.ts
export interface IDatabase {
  query<T>(sql: string, params?: any[]): Promise<T[]>;
}

// services/user.service.ts
export class UserService {
  constructor(
    private readonly database: IDatabase,
    private readonly logger: ILogger,
    private readonly cacheService?: ICacheService // optional
  ) {}

  async getUser(id: string): Promise<User> {
    this.logger.log(`Fetching user ${id}`);
    
    if (this.cacheService) {
      const cached = await this.cacheService.get(`user:${id}`);
      if (cached) return cached;
    }
    
    const users = await this.database.query<User>(
      'SELECT * FROM users WHERE id = ?',
      [id]
    );
    
    return users[0];
  }
}
```
</example>

<example type="property-injection">
```typescript
// services/notification.service.ts
export class NotificationService {
  // Required dependency via constructor
  constructor(private readonly emailService: IEmailService) {}
  
  // Optional dependency via property injection
  @Optional()
  public smsService?: ISmsService;
  
  @Optional()
  public pushService?: IPushService;
  
  async notify(user: User, message: string): Promise<void> {
    // Email is always available (required)
    await this.emailService.send(user.email, message);
    
    // SMS is optional
    if (this.smsService && user.phone) {
      await this.smsService.send(user.phone, message);
    }
    
    // Push is optional
    if (this.pushService && user.deviceToken) {
      await this.pushService.send(user.deviceToken, message);
    }
  }
}
```
</example>

<example type="circular-dependency-resolution">
```typescript
// BAD: Circular dependency
class OrderService {
  constructor(private userService: UserService) {}
}

class UserService {
  constructor(private orderService: OrderService) {} // Circular!
}

// GOOD: Extract shared functionality
interface IUserProvider {
  getUser(id: string): Promise<User>;
}

interface IOrderProvider {
  getUserOrders(userId: string): Promise<Order[]>;
}

class UserService implements IUserProvider {
  constructor(private database: IDatabase) {}
  
  async getUser(id: string): Promise<User> {
    return this.database.query('SELECT * FROM users WHERE id = ?', [id]);
  }
}

class OrderService implements IOrderProvider {
  constructor(
    private database: IDatabase,
    private userProvider: IUserProvider
  ) {}
  
  async getUserOrders(userId: string): Promise<Order[]> {
    const user = await this.userProvider.getUser(userId);
    return this.database.query('SELECT * FROM orders WHERE user_id = ?', [user.id]);
  }
}

// LAST RESORT: Lazy injection with factory
class ServiceA {
  constructor(private serviceBFactory: () => ServiceB) {}
  
  doSomething() {
    const serviceB = this.serviceBFactory(); // Lazy resolution
    serviceB.process();
  }
}
```
</example>

<example type="di-container-setup">
```typescript
// di-container.ts
import { Container } from 'inversify';

const container = new Container();

// Bind interfaces to implementations
container.bind<ILogger>('ILogger').to(ConsoleLogger).inSingletonScope();
container.bind<IDatabase>('IDatabase').to(PostgresDatabase).inSingletonScope();
container.bind<ICacheService>('ICacheService').to(RedisCache).inSingletonScope();

// Bind services
container.bind<UserService>(UserService).toSelf();
container.bind<OrderService>(OrderService).toSelf();

// Factory binding for circular dependencies
container.bind<() => ServiceB>('ServiceBFactory').toFactory((context) => {
  return () => context.container.get<ServiceB>(ServiceB);
});

export { container };
```
</example>
</examples>

</dependency-injection>