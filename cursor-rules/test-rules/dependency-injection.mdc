---
description: Guidelines for implementing dependency injection patterns in TypeScript, including constructor vs property injection and circular dependency resolution
globs:
alwaysApply: false
---
<dependency-injection>

<title>Dependency Injection in TypeScript</title>

<context>
<applies-to>TypeScript classes requiring dependency management, especially in enterprise applications using DI containers</applies-to>
</context>

<overview>Comprehensive guidelines for implementing dependency injection patterns, choosing between injection types, and resolving circular dependencies in TypeScript applications</overview>

<key-concepts>
- Inversion of Control (IoC) - Dependencies are provided rather than created
- Constructor injection - Dependencies passed through constructor
- Property injection - Dependencies assigned to properties
- Circular dependency - Two or more classes depend on each other
- DI container - Manages dependency creation and injection
</key-concepts>

<rules>
<rule>
<name>Constructor Injection (Default Approach)</name>
<requirements>
- Use for all required dependencies
- Mark injected dependencies as `private readonly`
- Inject interfaces, never concrete implementations
- List dependencies in order: framework services, application services, repositories
- Throw errors in constructor if required dependencies are missing
- Maximum 5 constructor parameters (refactor if more needed)
</requirements>
</rule>

<rule>
<name>Property Injection Usage</name>
<requirements>
- Use only for optional dependencies
- Mark properties with decorators like `@Optional()` or `@Inject()`
- Initialize with default implementations to prevent runtime errors
- Document why property injection was chosen over constructor injection
- Never use for core business logic dependencies
</requirements>
</rule>

<rule>
<name>Interface Design for DI</name>
<requirements>
- Define interfaces in separate files from implementations
- Keep interfaces focused on single responsibilities
- Use generic types for flexibility in implementations
- Avoid exposing implementation details in interfaces
- Name interfaces without `I` prefix (use `UserService` not `IUserService`)
</requirements>
</rule>

<rule>
<name>Circular Dependency Resolution</name>
<requirements>
- Detect cycles early using TypeScript compiler with `--preserveSymlinks`
- Extract shared functionality into a third service
- Use lazy injection with factory functions as last resort
- Consider event-based communication to break cycles
- Document any remaining circular dependencies with justification
- Use `forwardRef()` in frameworks that support it (Angular, NestJS)
</requirements>
</rule>

<rule>
<name>DI Container Configuration</name>
<requirements>
- Register dependencies at application startup
- Use scoped lifetimes appropriately (singleton, scoped, transient)
- Configure containers in dedicated modules
- Avoid service locator anti-pattern
- Use factory functions for complex initialization
- Keep container configuration separate from business logic
</requirements>
</rule>
</rules>

<examples>
<example type="constructor-injection">
```typescript
// interfaces/user-service.interface.ts
export interface UserService {
  findById(id: string): Promise<User>;
  create(data: CreateUserDto): Promise<User>;
}

// interfaces/logger.interface.ts
export interface Logger {
  log(message: string, context?: any): void;
  error(message: string, error?: Error): void;
}

// services/user.service.ts
import { Injectable } from '@decorators/di';
import { UserService } from '../interfaces/user-service.interface';
import { UserRepository } from '../interfaces/user-repository.interface';
import { Logger } from '../interfaces/logger.interface';
import { CacheService } from '../interfaces/cache.interface';

@Injectable()
export class UserServiceImpl implements UserService {
  constructor(
    private readonly logger: Logger,
    private readonly userRepository: UserRepository,
    private readonly cacheService: CacheService
  ) {
    if (!userRepository) {
      throw new Error('UserRepository is required');
    }
  }

  async findById(id: string): Promise<User> {
    const cached = await this.cacheService.get(`user:${id}`);
    if (cached) {
      this.logger.log('User retrieved from cache', { id });
      return cached;
    }

    const user = await this.userRepository.findById(id);
    await this.cacheService.set(`user:${id}`, user);
    return user;
  }
}
```
</example>

<example type="property-injection">
```typescript
// services/notification.service.ts
import { Injectable, Optional, Inject } from '@decorators/di';
import { EmailService } from '../interfaces/email.interface';
import { SmsService } from '../interfaces/sms.interface';
import { Logger } from '../interfaces/logger.interface';

@Injectable()
export class NotificationService {
  // Required dependency via constructor
  constructor(private readonly logger: Logger) {}

  // Optional dependencies via property injection
  @Optional()
  @Inject('EmailService')
  private emailService?: EmailService;

  @Optional()
  @Inject('SmsService')
  private smsService?: SmsService = new NoOpSmsService(); // Default implementation

  async notify(userId: string, message: string): Promise<void> {
    const promises: Promise<void>[] = [];

    if (this.emailService) {
      promises.push(this.emailService.send(userId, message));
    } else {
      this.logger.log('Email service not available, skipping email notification');
    }

    if (this.smsService) {
      promises.push(this.smsService.send(userId, message));
    }

    await Promise.allSettled(promises);
  }
}
```
</example>

<example type="circular-dependency-resolution">
```typescript
// BAD: Circular dependency
// services/order.service.ts
class OrderService {
  constructor(private userService: UserService) {} // UserService depends on OrderService
}

// services/user.service.ts
class UserService {
  constructor(private orderService: OrderService) {} // Circular!
}

// GOOD: Extract shared functionality
// services/user-order-mediator.service.ts
interface UserOrderMediator {
  getUserOrders(userId: string): Promise<Order[]>;
  getOrderUser(orderId: string): Promise<User>;
}

@Injectable()
class UserOrderMediatorImpl implements UserOrderMediator {
  constructor(
    private readonly userRepository: UserRepository,
    private readonly orderRepository: OrderRepository
  ) {}

  async getUserOrders(userId: string): Promise<Order[]> {
    return this.orderRepository.findByUserId(userId);
  }

  async getOrderUser(orderId: string): Promise<User> {
    const order = await this.orderRepository.findById(orderId);
    return this.userRepository.findById(order.userId);
  }
}

// Now both services can depend on the mediator
@Injectable()
class OrderService {
  constructor(private readonly mediator: UserOrderMediator) {}
}

@Injectable()
class UserService {
  constructor(private readonly mediator: UserOrderMediator) {}
}

// ALTERNATIVE: Lazy injection with factory
@Injectable()
class OrderService {
  private userService?: UserService;

  constructor(
    @Inject('UserServiceFactory')
    private readonly userServiceFactory: () => UserService
  ) {}

  private getUserService(): UserService {
    if (!this.userService) {
      this.userService = this.userServiceFactory();
    }
    return this.userService;
  }
}
```
</example>

<example type="container-configuration">
```typescript
// di-container.config.ts
import { Container } from 'inversify';
import { Logger, ConsoleLogger } from './interfaces/logger.interface';
import { UserService, UserServiceImpl } from './services/user.service';
import { UserRepository, UserRepositoryImpl } from './repositories/user.repository';

export function configureContainer(): Container {
  const container = new Container();

  // Singleton - shared instance
  container.bind<Logger>('Logger')
    .to(ConsoleLogger)
    .inSingletonScope();

  // Transient - new instance each time
  container.bind<UserService>('UserService')
    .to(UserServiceImpl)
    .inTransientScope();

  // Scoped - one instance per request
  container.bind<UserRepository>('UserRepository')
    .to(UserRepositoryImpl)
    .inRequestScope();

  // Factory binding for complex initialization
  container.bind<DatabaseConnection>('DatabaseConnection')
    .toDynamicValue(async (context) => {
      const config = context.container.get<Config>('Config');
      const connection = new DatabaseConnection(config.database);
      await connection.connect();
      return connection;
    })
    .inSingletonScope();

  // Conditional binding
  container.bind<CacheService>('CacheService')
    .toDynamicValue((context) => {
      const config = context.container.get<Config>('Config');
      return config.cache.enabled 
        ? new RedisCacheService(config.cache)
        : new InMemoryCacheService();
    })
    .inSingletonScope();

  return container;
}

// app.ts
import { configureContainer } from './di-container.config';

const container = configureContainer();
const app = new Application(container);
app.start();
```
</example>
</examples>

<anti-patterns>
- Service locator pattern - Passing container as dependency
- Property injection for required dependencies
- Circular dependencies without clear resolution strategy
- Creating dependencies inside constructors
- Using concrete classes instead of interfaces
- Over-injection - Classes with too many dependencies
- God services - Services that do too much
</anti-patterns>

<testing-considerations>
- Always inject dependencies to enable mocking
- Use test containers with mock implementations
- Create factory functions for test doubles
- Avoid partial mocks when possible
- Test circular dependency resolution separately
</testing-considerations>

</dependency-injection>