---
description: Enforce try-catch blocks for async operations with structured error logging
globs:
alwaysApply: false
---

<async-error-handling>

<title>Async Operations Error Handling</title>

<rules>
- Always wrap async operations in try-catch blocks
- Log all errors with structured logging format
- Include timestamp in ISO 8601 format
- Include error type classification (e.g., NetworkError, ValidationError, DatabaseError)
- Include user context when available (user ID, session ID, request ID)
- Preserve original error stack traces
- Use consistent error logging utility/service
- Never swallow errors silently
- Re-throw errors after logging when propagation is needed
</rules>

<examples>
<example type="good">
```typescript
async function fetchUserData(userId: string, sessionId: string): Promise<UserData> {
  try {
    const response = await api.get(`/users/${userId}`);
    return response.data;
  } catch (error) {
    logger.error({
      timestamp: new Date().toISOString(),
      errorType: error instanceof NetworkError ? 'NetworkError' : 'UnknownError',
      message: error.message,
      stack: error.stack,
      context: {
        userId,
        sessionId,
        operation: 'fetchUserData',
        endpoint: `/users/${userId}`
      }
    });
    throw error;
  }
}
```
</example>

<example type="good">
```javascript
async function processPayment(paymentData, requestId) {
  try {
    const result = await paymentService.process(paymentData);
    return result;
  } catch (error) {
    await errorLogger.log({
      timestamp: new Date().toISOString(),
      errorType: classifyError(error),
      message: error.message,
      stack: error.stack,
      context: {
        userId: paymentData.userId,
        requestId,
        operation: 'processPayment',
        amount: paymentData.amount
      }
    });
    throw new ProcessingError('Payment processing failed', { cause: error });
  }
}
```
</example>
</examples>

</async-error-handling>