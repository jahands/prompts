---
description: Cursor rule guidelines (ALWAYS read before adding/updating rules)
globs:
alwaysApply: false
---
<cursor-rules-guide>

<title>Cursor Rules - Organization and Format</title>

<location>
<description>All cursor rules should be placed in the `.cursor/rules/` directory with the `.mdc` extension.</description>

<requirements type="dont">
- `.cursorrules` file in the root (deprecated)
- Rules in other locations
- Rules with other extensions
</requirements>

<requirements type="do">
- `.cursor/rules/{descriptive-name}.mdc`
- One rule per file
- Clear, focused rules
</requirements>
</location>

<file-naming>
<requirements>
- Use kebab-case: `my-rule-name.mdc`
- Be descriptive but concise
- Group related rules with common prefixes
</requirements>

<examples>
- `github-actions-runners.mdc`
- `docker-compose.mdc`
- `development-workflow.mdc`
</examples>
</file-naming>

<rule-format>
<description>Rules must be written for LLM optimization. Prioritize machine readability over human readability.</description>

<template>
<code language="xml">
<rule-name-guidelines>

<title>Rule Title - Brief Description</title>

<description>What this rule helps with</description>

<context>
<applies-to>Where this rule applies (files, directories, etc.)</applies-to>
</context>

<overview>
<content>High-level explanation of the system/pattern</content>
</overview>

<key-concepts>
- First important concept
- Second important concept
- Additional concepts as needed
</key-concepts>

<rules>
<rule>
<name>Rule name</name>
<requirements>
- First requirement or detail
- Second requirement or detail
- Additional requirements
</requirements>
</rule>

<rule>
<name>Another rule</name>
<steps>
1. First numbered step (when order matters)
2. Second numbered step
3. Third numbered step
</steps>
</rule>
</rules>

<examples>
<example type="good">
<code language="typescript">
// Good example code here
</code>
</example>
<example type="bad">
<code language="typescript">
// Bad example code here
</code>
</example>
</examples>

</rule-name-guidelines>
</code>
</template>

<xml-tag-guidelines>

<structure-requirements>
- XML tags only - No markdown headers or formatting
- Every section needs an XML tag
- Use dash lists within tags to save tokens
- No visual formatting (bold, italic, emojis)
- Consistent nesting and clear parent-child relationships
</structure-requirements>

<xml-benefits>
- Unambiguous parsing - no regex needed for headers
- Explicit hierarchy - parent-child relationships are clear
- Consistent extraction - same path to data every time
- No formatting ambiguity - ## vs ### doesn't matter
</xml-benefits>

<common-mistakes>
- Mixing markdown headers with XML tags
- Using XML tags for formatting (like <bold>)
- Creating deeply nested structures (>4 levels)
- Inconsistent attribute naming
</common-mistakes>

<token-optimization>
- XML tag pair: ~2-3 tokens
- Dash list item: ~1 token
- Individual XML elements: ~4-5 tokens each
- Choose lists when >3 similar items
</token-optimization>

<tag-design-principles>
- Semantic names - Tags describe content, not formatting
- Lowercase with hyphens - Use rule-name not RuleName or rule_name
- Attributes for metadata - Use type="good", language="typescript"
- Specific over generic - Use requirement not item, concept not point
- No redundant text - Let tags convey meaning
</tag-design-principles>

<optimization-rules>
- No markdown headers (#, ##, ###) - Use XML structure only
- No text formatting (**bold**, *italic*) - Unnecessary for LLMs
- No emojis or Unicode symbols - Use type attributes instead
- No redundant labels - If tag is named "examples", don't add "Examples:" text
- Use attributes for categorization - type="good" not separate good/bad sections
- Consistent patterns throughout - Same structure for similar content
</optimization-rules>

<list-patterns>
<pattern type="unordered">
<description>Use dash lists for most content</description>
<code language="xml">
<requirements>
- Each requirement is important
- Order doesn't matter
- Keep items concise
</requirements>
</code>
</pattern>

<pattern type="ordered">
<description>Use numbered lists only when order is critical</description>
<code language="xml">
<steps>
1. First do this
2. Then do that
3. Finally do this
</steps>
</code>
</pattern>

<pattern type="key-value">
<description>For type definitions, use consistent format</description>
<code language="xml">
<types>
- `feat:` - New feature or functionality
- `fix:` - Bug fix
- `chore:` - Maintenance tasks
</types>
</code>
</pattern>
</list-patterns>

<common-patterns>
<pattern>
<name>Lists save tokens vs individual tags</name>
<code language="xml">
<concepts>
- Concept one explanation
- Concept two explanation
- Concept three explanation
</concepts>
</code>
</pattern>

<pattern>
<name>Code examples with attributes</name>
<code language="xml">
<example type="good">
<code language="typescript">
// Code here
</code>
</example>
</code>
</pattern>

<pattern>
<name>Structured comparisons</name>
<code language="xml">
<comparison>
<before>Old approach</before>
<after>New approach</after>
</comparison>
</code>
</pattern>
</common-patterns>

<avoid>
- Markdown formatting inside XML
- Visual elements (emojis, symbols)
- Redundant text that duplicates tag names
- Generic tags like section, div, content
- Inconsistent structure patterns
- Human-oriented formatting
</avoid>

<benefits>
- Unambiguous structure for parsing
- Clear data extraction paths
- Consistent patterns across all rules
- No markdown parsing required
- Explicit relationships between elements
- Optimal token usage
</benefits>

</xml-tag-guidelines>

<rule-complexity-guidelines>

<principle>Use the minimum structure needed for clarity - no more, no less</principle>

<simple-rules>
<when>For straightforward behavioral rules (< 10 requirements)</when>
<approach>
- Single <rules> section with dash list
- Skip sections that add no value (overview, concepts)
- 10-30 lines total
</approach>
<examples>
- Communication style
- Naming conventions
- Simple do/don't lists
</examples>
</simple-rules>

<complex-rules>
<when>For technical systems or multi-faceted implementations</when>
<approach>
- Full template with multiple sections
- Include overview, concepts, examples
- Detailed requirements and steps
</approach>
<examples>
- API design patterns
- Architecture guidelines
- Multi-step processes
</examples>
</complex-rules>

<anti-pattern>
<description>Don't over-structure simple content</description>
<example type="bad">
50+ lines of XML with nested sections for "don't use filler phrases"
</example>
<example type="good">
<code language="xml">
<direct-communication>
<rules>
- Skip pleasantries and affirmations
- Don't start with "Great question!", "You're right!", etc.
- Begin directly with the answer
- Focus on content, not meta-commentary
</rules>
</direct-communication>
</code>
</example>
</anti-pattern>

<token-efficiency>
- Simple rule with minimal XML: ~50-100 tokens
- Over-structured simple rule: ~200-300 tokens
- Complex rule with full structure: ~300-500 tokens (justified by content)
</token-efficiency>
</rule-complexity-guidelines>
</rule-format>

<best-practices>
- Optimize for LLM parsing - Remove all human-oriented formatting
- Use XML structure exclusively - No markdown headers or formatting
- Dash lists within tags - Saves tokens while maintaining structure
- Semantic tag names - Describe content, not presentation
- Consistent patterns - Same structure for similar content types
- Single-purpose rules - One topic per file
- Regular updates - Keep rules current with codebase changes
- Remove obsolete rules - Don't keep outdated information
- No visual formatting - No bold, italic, or emojis
- Let tags convey meaning - Avoid redundant text
</best-practices>

</cursor-rules-guide>
